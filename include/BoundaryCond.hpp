#ifndef BOUNDARY_COND_HPP
#define BOUNDARY_COND_HPP
// ==================================================================
// BoundaryCond.hpp
// Object: 
// Define the dirichlet, periodic slave/master nodes in the boundary;
// Define the element on the boundary with specification of face 
// directions.
// 
// Output:
// 1. number of dirichlet nodes, and these nodes' global indices;
// 2. number of periodic nodes, and the master-slave's global indices;
// 3. ID array for the strong imposition of boundary conditions;
// 4. the global indices of elements that have faces on the 
//    front   back   left   right  top   bottom
//    boundary faces.
//
// Date: Sept 25th 2013 
// ==================================================================
#include <cassert>
#include "Mesh_NURBS_1Patch_3D.hpp"
#include "Mesh_NURBS_1ofnPatch_3D.hpp"

class BoundaryCond
{
  public:
    BoundaryCond( const IMesh * const &mesh, const int &bc_type );
    
    // This construcotr requires control points as input. This procedure is
    // typically needed when do automatic pairing for interior interfaces.
    BoundaryCond( const IMesh * const &mesh, const int &bc_type, 
       const std::vector<double> &cPts );

    virtual ~BoundaryCond();

    // Read permission to private data
    int get_dir_nodes(unsigned int ii) const {return dir_nodes[ii];}
    int get_per_slave_nodes(unsigned int ii) const {return per_slave_nodes[ii];}
    int get_per_master_nodes(unsigned int ii) const {return per_master_nodes[ii];}
    unsigned int get_num_dir_nodes() const {return num_dir_nodes;}
    unsigned int get_num_per_nodes() const {return num_per_nodes;}
    int get_ID(unsigned int ii) const {return ID[ii];}
    unsigned int get_num_ID() const {return ID.size();}

    int get_front_elem(unsigned int ii) const {return front_elem[ii];}
    unsigned int get_num_front_elem() const {return num_front_elem;}
    int get_back_elem(unsigned int ii) const {return back_elem[ii];}
    unsigned int get_num_back_elem() const {return num_back_elem;}
    int get_left_elem(unsigned int ii) const {return left_elem[ii];}
    unsigned int get_num_left_elem() const {return num_left_elem;}
    int get_right_elem(unsigned int ii) const {return right_elem[ii];}
    unsigned int get_num_right_elem() const {return num_right_elem;}
    int get_top_elem(unsigned int ii) const {return top_elem[ii];}
    unsigned int get_num_top_elem() const {return num_top_elem;}
    int get_bottom_elem(unsigned int ii) const {return bottom_elem[ii];}
    unsigned int get_num_bottom_elem() const {return num_bottom_elem;}

    // Info print
    void print_info() const;
    void print_face_edge_corner_nodes(const IMesh * const &mesh) const;

    // print the nodes generated by generate_BCNodes_C function
    void print_face_edge_corner_nodes_2(const IMesh * const &mesh) const;

  private:
    // --------- Core Components --------------
    // boundary condition type
    const int bctype;
    
    // vector storing dirichlet nodes
    std::vector<int> dir_nodes;
    unsigned int num_dir_nodes;

    // vector for periodic slave master nodes
    std::vector<int> per_slave_nodes, per_master_nodes;
    unsigned int num_per_nodes;

    // vector for id array
    std::vector<int> ID;

    // vector for boundary element with faces in the front
    std::vector<int> front_elem, back_elem, left_elem, right_elem, top_elem, bottom_elem;

    // number of these elements
    unsigned int num_front_elem, num_back_elem;
    unsigned int num_left_elem, num_right_elem;
    unsigned int num_top_elem, num_bottom_elem;


    // ------------------------------------------------------------------------
    // Initializing all data
    // ------------------------------------------------------------------------
    void Clear_nodes();
    void Clear_elems();


    // -------------------------------------------------------------------------
    // Function to generate ID array according to the dir and per nodes
    // -------------------------------------------------------------------------
    void Create_ID( const IMesh * const &mesh);

    void Create_ID( const s_int &in_nfunc );

    // -------------------------------------------------------------------------
    // Function that generate node global indices based on IMesh.This may helps 
    // generate simpler bc specification routine. But this function is not
    // necessary for generating boundary condition class. The user may specify
    // boundary nodes in their own way in general.
    // In [0,1]^3 cube, front: [1,y,z]; back: [0,y,z]; 
    //                  left: [x,0,z]; right: [x,1,z];
    //                  top:   [x,y,1]; bottom: [x,y,0].  
    // -------------------------------------------------------------------------
    void Generate_BCNodes_A( const IMesh * const &mesh,
        std::vector<int> &front, std::vector<int> &back, std::vector<int> &left,
        std::vector<int> &right, std::vector<int> &top, std::vector<int> &bottom ) const;


    // -------------------------------------------------------------------------
    // generator B. Gives more specific specification of boundary nodes:
    // face nodes in front, back, left, right, top, and bottom.
    // edge nodes in edge 01 02 13 23 45 46 57 67 15 37 04 26
    // corner nodes at 0 1 2 3 4 5 6 7
    // -------------------------------------------------------------------------
    void Generate_BCNodes_B( const IMesh * const &mesh,
        std::vector<int> &front, std::vector<int> &back, std::vector<int> &left,
        std::vector<int> &right, std::vector<int> &top, std::vector<int> &bottom,
        std::vector<int> &edge01, std::vector<int> &edge02, std::vector<int> &edge13,
        std::vector<int> &edge23, std::vector<int> &edge45, std::vector<int> &edge46,
        std::vector<int> &edge57, std::vector<int> &edge67, std::vector<int> &edge15,
        std::vector<int> &edge37, std::vector<int> &edge04, std::vector<int> &edge26,
        std::vector<int> &corner ) const;


    // -------------------------------------------------------------------------
    // generator C. Gives the specification of interior cube's boundary
    // nodes. Such specification is useful for strong enforcement of C1 type
    // boundary conditions. The date structure is defined in such a way:
    // 1. The six faces are defined similar to the way we defined in _A;
    // 2. The 12 edges, excluding 8 corner points are listed similar to _B;
    // 3. The 8 corner nodes are defined.
    // Refer to the function BC_type_13 for an example of the use of this _C
    // node generation function.
    // -------------------------------------------------------------------------
    void Generate_BCNodes_C( const IMesh * const &mesh,
        std::vector<int> &front, std::vector<int> &back, std::vector<int> &left,
        std::vector<int> &right, std::vector<int> &top, std::vector<int> &bottom,
        std::vector<int> &edge01, std::vector<int> &edge02, std::vector<int> &edge13,
        std::vector<int> &edge23, std::vector<int> &edge45, std::vector<int> &edge46,
        std::vector<int> &edge57, std::vector<int> &edge67, std::vector<int> &edge15,
        std::vector<int> &edge37, std::vector<int> &edge04, std::vector<int> &edge26,
        std::vector<int> &corner ) const;


    // ------------------------------------------------------------------------
    // Generate_BCNodes_D is a fast implementation of the Generate_BCNodes_B
    // function.
    // 0. In this implementation, we added a parameter f_start for multipatch
    // cases. For single patch or the 0-th patch, f_start = 0. For multipatch,
    // f_start = mesh->get_nFunc_start().
    // 
    // 1. One difference is that we will pass the data out by pointers which 
    // allocate dynamic arrays. The users are RESPONSIBLE for delete all these 
    // arrays to free the heap space.
    //
    // 2. To make data local, we put front node and back node together, left
    // node and right node togeter, top and bottom face nodes together. We will
    // pass out a parater to identify the starting index for the second data.
    // back_front: 
    //       0   <= index < nbf   gives the back face nodes;
    //       nbf <= index < 2*nbf gives the front face nodes;
    // left_right:
    //       0   <= index < nlr   gives the left face nodes;
    //       nlr <= index < 2*nlr gives the right face nodes;
    // bottom_top:
    //       0   <= index < nbt   gives the bottom face nodes;
    //       nbt <= index < 2*nbt gives the top face nodes.
    // edge01 stores the edge 01 23 45 67 nodes:
    //       0   <= ii < nex   gives edge 01;
    //       nex <= ii < 2*nex gives edge 23;
    //     2*nex <= ii < 3*nex gives edge 45;
    //     3*nex <= ii < 4*nex gives edge 67.
    // edge02 stores the edge 02 13 46 57 nodes:
    //       0   <= ii < ney   gives edge 02;
    //       ney <= ii < 2*ney gives edge 13;
    //     2*ney <= ii < 3*ney gives edge 46;
    //     3*ney <= ii < 4*ney gives edge 57.
    // edge04 stores the edge 04 15 26 37 nodes:
    //       0   <= ii < nez   gives edge 04;
    //       nez <= ii < 2*nez gives edge 15;
    //     2*nez <= ii < 3*nez gives edge 26;
    //     3*nez <= ii < 4*nez gives edge 37.
    // corner pointer stores 8 nodes from 0 to 7.
    // ------------------------------------------------------------------------
    void Generate_BCNodes_D( const int &nFunc_x, const int &nFunc_y,
        const int &nFunc_z, const int &f_start,
        int * &back_front, int &nbf,
        int * &left_right, int &nlr,
        int * &bottom_top, int &nbt,
        int * &edge01, int &nex,
        int * &edge02, int &ney,
        int * &edge04, int &nez,
        int * &corner ) const;


    // -------------------------------------------------------------------------
    // Similar to the function for nodes, but list the elements that has faces
    // on the boundary. 
    // -------------------------------------------------------------------------
    void Generate_BCElems_A( const IMesh * const &mesh,
        std::vector<int> &front, std::vector<int> &back, std::vector<int> &left,
        std::vector<int> &right, std::vector<int> &top, std::vector<int> &bottom ) const;


    // ------------------------------------------------------------------------
    // Generate_BCElems_B is a similar function to the _A version. It takes into
    // account of the nonzero starting element index, which is useful for
    // multipatch cases.
    // ------------------------------------------------------------------------
    void Generate_BCElems_B( const IMesh * const &mesh,
        std::vector<int> &front, std::vector<int> &back, std::vector<int> &left,
        std::vector<int> &right, std::vector<int> &top, std::vector<int> &bottom ) const;

    
    // ------------------------------------------------------------------------
    // Read_SH_interface_pair() is a reader that reads in the interior interface
    // infomation from the global_data.dat of Shaolie's input files. Note: In
    // shaolie's file, the first patch start with 1. Bottom of a patch is face 1
    // and top of a patch is face 6.
    // ------------------------------------------------------------------------
    void Read_SH_interface_pair(const std::string &interface_file,
        std::vector<int> &patch1, std::vector<int> &patch2, 
        std::vector<int> &face1, std::vector<int> &face2 ) const;


    // ------------------------------------------------------------------------
    // BC_test_1 is an internal test funciton.
    //           To call it, give bc_type -1 in the constructor.
    //           This function tests the behavior of the function
    //           Generate_BCNodes_D.
    // ------------------------------------------------------------------------
    void BC_test_1() const;


    // ------------------------------------------------------------------------
    // BC_test_2 is an internal test funciton.
    //           To call it, give bc_type -2 in the constructor.
    //           This function tests the behavior of the function
    //           Generate_BCElems_B.
    // ------------------------------------------------------------------------
    void BC_test_2() const;

    // -------------------------------------------------------------------------
    // The following functions are added by users to generate different BC
    // pattern. These funcitons only needs to specify the boundary nodes and
    // the boundary conditions on these nodes; and the boundary elements.
    // -------------------------------------------------------------------------

    // -------------------------------------------------------------------------
    // BC_type_1: all nodes are dirichlet, no boundary element
    // -------------------------------------------------------------------------
    void BC_type_1( const IMesh * const &mesh );


    // -------------------------------------------------------------------------
    // BC_type_2: full periodic. Top-bottom, left-right, front-back.
    // -------------------------------------------------------------------------
    void BC_type_2( const IMesh * const &mesh );


    // -------------------------------------------------------------------------
    // BC_tyoe_3: no strong imposition, no boundary integral
    // -------------------------------------------------------------------------
    void BC_type_3( const IMesh * const &mesh );


    // -------------------------------------------------------------------------
    // BC_type_4: front-back periodic, top, bottom, left, right dirichlet
    // -------------------------------------------------------------------------
    void BC_type_4( const IMesh * const &mesh );


    // -------------------------------------------------------------------------
    // BC_type_5: front-back periodic, top, bottom, left, right no strong
    //            imposition, no boundary integral as well. 
    // -------------------------------------------------------------------------
    void BC_type_5( const IMesh * const &mesh );


    // -------------------------------------------------------------------------
    // BC_tyoe_6: no imposition of strong nodal bc. weak imposition on all faces
    // -------------------------------------------------------------------------
    void BC_type_6( const IMesh * const &mesh );


    // -------------------------------------------------------------------------
    // BC_tyoe_7: no imposition of strong nodal bc. weak imposition on bottom
    // -------------------------------------------------------------------------
    void BC_type_7( const IMesh * const &mesh );


    // -------------------------------------------------------------------------
    // BC_type_8: full periodic, fast version
    // -------------------------------------------------------------------------
    void BC_type_8( const IMesh * const &mesh );


    // -------------------------------------------------------------------------
    // BC_type_9: interior nodes of front-back are periodic, rest nodes are 
    //            no strong imposition/no boundary integral
    // -------------------------------------------------------------------------
    void BC_type_9( const IMesh * const &mesh );


    // -------------------------------------------------------------------------
    // BC_type_10: interior nodes of front-back are periodic, 
    //             rest nodes are dirichlet
    // -------------------------------------------------------------------------
    void BC_type_10( const IMesh * const &mesh );


    // -------------------------------------------------------------------------
    // BC_type_11: interior nodes of front-back, top-bottom are periodic, 
    //             rest nodes has no strong imposition
    // -------------------------------------------------------------------------
    void BC_type_11( const IMesh * const &mesh );


    // -------------------------------------------------------------------------
    // BC_type_12: interior nodes of front-back, top-bottom are periodic, 
    //             rest nodes are dirichlet 
    // -------------------------------------------------------------------------
    void BC_type_12( const IMesh * const &mesh );


    // -------------------------------------------------------------------------
    // BC_type_13: strong enforcement for \nabla \cdot c = 0 for C1 basis
    // -------------------------------------------------------------------------
    void BC_type_13( const IMesh * const &mesh );


    // -------------------------------------------------------------------------
    // BC_type_14: Front and Back faces, including edges and corner nodes
    //             Dirichlet. Slip BC for vel u
    // -------------------------------------------------------------------------
    void BC_type_14( const IMesh * const &mesh );


    // -------------------------------------------------------------------------
    // BC_type_15: Left and Right faces, including adjacent edges and all corner
    //             nodes are Dirichlet. Slip BC for vel v
    // -------------------------------------------------------------------------
    void BC_type_15( const IMesh * const &mesh );


    // -------------------------------------------------------------------------
    // BC_type_16: Top and Bottom faces, including adjacent edges and all corner
    //             nodes are Dirichlet. Slip BC for vel w
    // -------------------------------------------------------------------------
    void BC_type_16( const IMesh * const &mesh );


    // -------------------------------------------------------------------------
    // BC_type_17: Fixed the value at the (0,0,0) point. Rest nodes has no BC
    //             imposition. Use this for pressure in NS solver when Dirichlet
    //             BC are imposed for velocity field on all boundary nodes.
    // -------------------------------------------------------------------------
    void BC_type_17( const IMesh * const &mesh );


    // -------------------------------------------------------------------------
    // BC_type_18: Dirichlet at Top/Left/Right/Front/Back
    //             Do nothing at Bottom
    // -------------------------------------------------------------------------
    void BC_type_18( const IMesh * const &mesh );


    // -------------------------------------------------------------------------
    // BC_type_19: This is a combination of Dirichelt and C0 periodic BC for 
    //             the simulation of Poiseuille problem using C0 parametrization.
    //             This boundary condition is used for the three velocity
    //             components.
    //             Top: Dirichlet, Bottom: Nothing
    //             Front -- Back C0 periodic
    //             Left: Nothing, Right: Dirichlet
    // -------------------------------------------------------------------------
    void BC_type_19( const IMesh * const &mesh );


    // -------------------------------------------------------------------------
    // BC_type_20: This is used in combination with 19, as a boundary condition
    //             for the corresponding pressure variable.
    //             Top, Bottom, Left, Right : Nothing
    //             Front -- Back C0 periodic
    // -------------------------------------------------------------------------
    void BC_type_20( const IMesh * const &mesh );


    // -------------------------------------------------------------------------
    // BC_type_21 : Boundary face integral on top.
    //              Dirichlet BC on the rest faces
    // -------------------------------------------------------------------------
    void BC_type_21( const IMesh * const &mesh );


    // -------------------------------------------------------------------------
    // BC_type_22 : Boundary face integral on bottom.
    //              No nodal strong specification. No other boundary face 
    //              specification.
    // -------------------------------------------------------------------------
    void BC_type_22( const IMesh * const &mesh );


    // -------------------------------------------------------------------------
    // BC_type_23 : In addition to BC_type_22, we have:
    //               Right face impose master-slave relation to
    //              make the node on the same line parallel to s-axis follow the
    //              node on edge 37. This BC is inspired by the fact that these
    //              points collapse to a single point in the physical domain.
    //              Hence, they should have a master-slave relation.
    // -------------------------------------------------------------------------
    void BC_type_23( const IMesh * const &mesh );




    // ------------------------------------------------------------------------
    // BC_type_101 : Starting from 101, we implement boundary conditions for
    //               multipatch geometries.
    //               The input mesh should be the global mesh handler, which may
    //               provide a pointer to each specific patch. 
    //               This one is an implementation for 3-patch coronary geometry
    //               with a bifircation at the three patch interface.
    //               The bifircation interface contains patch 0's top, patch 1'
    //               top, and patch 2's bottom
    // ------------------------------------------------------------------------
    void BC_type_101( const IMesh * const &mesh );



    // ------------------------------------------------------------------------
    // BC_type_102 : The input mesh should be the global mesh for 3-patch
    //               coronary geometry. The bifircation interface contains patch
    //               0's top, patch 1's bottom, and patch 2's top.
    //               The patch 0's bottom, patch 1's top, and patch 2's bottom
    //               are imposed with NBC (i.e., boundary integration.)
    //               Dirichlet boundary are imposed on the left (outer surface)
    //               of each patch; nothing is imposed on the right surface for
    //               each patch.
    // ------------------------------------------------------------------------
    void BC_type_102( const IMesh * const &mesh );



    // ------------------------------------------------------------------------
    // BC_type_103 : This is similar to 102. We impose Dirichlet BC on the top
    //               surface of patch 0 for inflow condition. Weak imposition of
    //               NBC on top of patch 1 and bottom of patch 2. 
    // ------------------------------------------------------------------------
    void BC_type_103( const IMesh * const &mesh );


    // ------------------------------------------------------------------------
    // BC_type_104 : This is an improved version of specifiying BC for the
    //               3-patch coronary geometry. The interior interface is read
    //               from the given file; the interior master-slave relation is
    //               then automatically defined by grouping the control points
    //               that share identical physical control points. 
    //               NBC are imposed on patch 0 & 2's bottom and patch 1's top.
    // ------------------------------------------------------------------------
    void BC_type_104( const IMesh * const &mesh, const std::vector<double> &cPts );    


    // ------------------------------------------------------------------------
    // BC_type_105 : This BC type imposes master-slave relation similar to
    //               BC_type_104; in addition to what was imposed in 104, we add
    //               master-slave relation on the LEFT face including the edge01
    //               and edge45.
    // ------------------------------------------------------------------------
    void BC_type_105( const IMesh * const &mesh, const std::vector<double> &cPts );




    // ------------------------------------------------------------------------
    // BC_type_200 : This is BC for the 107-patch pig coronary geometries.
    //               The interior interfaces are automatically paired;
    //               NBC are imposed on patch 0 only;
    //               Dirichlet on All Right faces. 
    // ------------------------------------------------------------------------
    void BC_type_200( const IMesh * const &mesh, const std::vector<double> &cPts );
    
    // ------------------------------------------------------------------------
    // BC_type_201 : This is BC for the 107-patch pig coronary geometries.
    //               In addition to BC_type_200, master-slave relations are
    //               added to the LEFT face, including the edge01 and edge45. 
    // ------------------------------------------------------------------------
    void BC_type_201( const IMesh * const &mesh, const std::vector<double> &cPts );




};


#endif
